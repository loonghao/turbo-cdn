// Licensed under the MIT License
// Copyright (c) 2025 Hal <hal.long@outlook.com>

//! Core functionality tests for turbo-cdn
//!
//! This module contains essential unit tests for the core components.

use turbo_cdn::*;

/// Test configuration loading and validation
#[test]
fn test_config_loading() {
    let config = config::TurboCdnConfig::default();
    
    // Test default values
    assert_eq!(config.performance.max_concurrent_downloads, 16);
    assert_eq!(config.performance.chunk_size, 2 * 1024 * 1024);
    assert_eq!(config.performance.timeout, 30);
    assert!(config.performance.adaptive_chunking);
    assert_eq!(config.performance.min_chunk_size, 256 * 1024);
    assert_eq!(config.performance.max_chunk_size, 10 * 1024 * 1024);
    
    // Test security settings
    assert!(config.security.verify_ssl);
    assert!(config.security.allowed_protocols.contains(&"https".to_string()));
    
    // Test geo detection settings
    assert!(config.geo_detection.auto_detect_region);
    assert!(!config.geo_detection.ip_apis.is_empty());
    assert_eq!(config.geo_detection.ip_detection_timeout, 5);
}

/// Test URL mapping functionality
#[test]
fn test_url_mapping() {
    let config = config::TurboCdnConfig::default();
    let mut mapper = url_mapper::UrlMapper::new(&config, config::Region::China).unwrap();
    
    // Test GitHub URL mapping
    let github_url = "https://github.com/user/repo/releases/download/v1.0.0/file.zip";
    let mapped_urls = mapper.map_url(github_url).unwrap();
    
    assert!(!mapped_urls.is_empty());
    assert!(mapped_urls.contains(&github_url.to_string()));
    
    // Should have CDN alternatives for China region
    let has_cdn_alternative = mapped_urls.iter().any(|url| 
        url.contains("ghproxy.net") || 
        url.contains("ghfast.top") || 
        url.contains("mirror.ghproxy.com")
    );
    assert!(has_cdn_alternative);
}

/// Test jsDelivr URL mapping
#[test]
fn test_jsdelivr_mapping() {
    let config = config::TurboCdnConfig::default();
    let mut mapper = url_mapper::UrlMapper::new(&config, config::Region::Global).unwrap();
    
    let jsdelivr_url = "https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js";
    let mapped_urls = mapper.map_url(jsdelivr_url).unwrap();
    
    assert!(!mapped_urls.is_empty());
    assert!(mapped_urls.contains(&jsdelivr_url.to_string()));
    
    // Should have CDN alternatives
    let has_cdn_alternative = mapped_urls.iter().any(|url| 
        url.contains("fastly.jsdelivr.net") || 
        url.contains("gcore.jsdelivr.net")
    );
    assert!(has_cdn_alternative);
}

/// Test unknown URL passthrough
#[test]
fn test_unknown_url_passthrough() {
    let config = config::TurboCdnConfig::default();
    let mut mapper = url_mapper::UrlMapper::new(&config, config::Region::Global).unwrap();
    
    let unknown_url = "https://example.com/unknown/file.zip";
    let mapped_urls = mapper.map_url(unknown_url).unwrap();
    
    assert_eq!(mapped_urls.len(), 1);
    assert_eq!(mapped_urls[0], unknown_url);
}

/// Test server performance tracking
#[test]
fn test_server_performance_tracking() {
    use server_tracker::ServerTracker;
    use std::time::Duration;
    
    let mut tracker = ServerTracker::new();
    
    // Record performance data
    tracker.record_success("http://fast.example.com", 10.0 * 1024.0 * 1024.0, Duration::from_millis(100));
    tracker.record_success("http://slow.example.com", 1.0 * 1024.0 * 1024.0, Duration::from_millis(500));
    tracker.record_failure("http://bad.example.com", Duration::from_millis(2000));
    
    // Test server selection
    let urls = vec![
        "http://fast.example.com".to_string(),
        "http://slow.example.com".to_string(),
        "http://bad.example.com".to_string(),
    ];
    
    let selected = tracker.select_best_servers(&urls, 2);
    assert_eq!(selected.len(), 2);
    
    // Fast server should be selected first
    assert_eq!(selected[0], "http://fast.example.com");
    
    // Test performance summary
    let summary = tracker.get_performance_summary();
    assert_eq!(summary.total_servers, 3);
    assert_eq!(summary.total_attempts, 3);
    assert_eq!(summary.total_successes, 2);
}

/// Test error handling
#[test]
fn test_error_handling() {
    use error::TurboCdnError;
    
    // Test error creation
    let network_error = TurboCdnError::network("Connection failed");
    assert!(network_error.to_string().contains("Network error"));
    
    let config_error = TurboCdnError::config("Invalid configuration");
    assert!(config_error.to_string().contains("Configuration error"));
    
    let io_error = TurboCdnError::io("File not found");
    assert!(io_error.to_string().contains("IO error"));
}

/// Test region detection
#[test]
fn test_region_detection() {
    use config::Region;
    
    // Test region enum
    assert_eq!(Region::China.to_string(), "China");
    assert_eq!(Region::Global.to_string(), "Global");
    assert_eq!(Region::AsiaPacific.to_string(), "AsiaPacific");
}

/// Test CDN quality metrics
#[test]
fn test_cdn_quality_metrics() {
    use cdn_quality::CdnMetrics;
    
    let metrics = CdnMetrics::default();
    
    assert_eq!(metrics.latency_ms, 0.0);
    assert_eq!(metrics.bandwidth_bps, 0.0);
    assert_eq!(metrics.success_rate, 1.0);
    assert_eq!(metrics.availability, 1.0);
    assert_eq!(metrics.quality_score, 50.0);
    assert_eq!(metrics.test_count, 0);
}

/// Test download options builder pattern
#[test]
fn test_download_options_builder() {
    use std::time::Duration;
    
    let options = DownloadOptions::new()
        .with_max_concurrent_chunks(8)
        .with_chunk_size(1024 * 1024)
        .with_resume(true)
        .with_header("User-Agent", "test-agent")
        .with_timeout(Duration::from_secs(60))
        .with_integrity_verification(true)
        .with_expected_size(1024 * 1024);
    
    assert_eq!(options.max_concurrent_chunks, Some(8));
    assert_eq!(options.chunk_size, Some(1024 * 1024));
    assert!(options.enable_resume);
    assert!(options.verify_integrity);
    assert_eq!(options.expected_size, Some(1024 * 1024));
    assert_eq!(options.timeout_override, Some(Duration::from_secs(60)));
    
    if let Some(ref headers) = options.custom_headers {
        assert_eq!(headers.get("User-Agent"), Some(&"test-agent".to_string()));
    }
}

/// Test URL validation
#[test]
fn test_url_validation() {
    // Valid URLs
    assert!(url::Url::parse("https://github.com/user/repo/releases/download/v1.0.0/file.zip").is_ok());
    assert!(url::Url::parse("https://cdn.jsdelivr.net/npm/package@1.0.0/dist/package.min.js").is_ok());
    
    // Invalid URLs
    assert!(url::Url::parse("not-a-url").is_err());
    assert!(url::Url::parse("ftp://example.com/file.zip").is_ok()); // Valid but might not be supported
}

/// Test concurrent downloader configuration
#[test]
fn test_concurrent_downloader_config() {
    let config = config::TurboCdnConfig::default();
    let downloader = concurrent_downloader::ConcurrentDownloader::with_config(&config);
    
    assert!(downloader.is_ok());
    
    let downloader = downloader.unwrap();
    let stats = downloader.get_server_stats();
    
    // Initially no servers tracked
    assert_eq!(stats.total_servers, 0);
    assert_eq!(stats.total_attempts, 0);
    assert_eq!(stats.total_successes, 0);
}

/// Test file size formatting
#[test]
fn test_file_size_formatting() {
    // Test various file sizes
    assert_eq!(format_file_size(1024), "1.00 KB");
    assert_eq!(format_file_size(1024 * 1024), "1.00 MB");
    assert_eq!(format_file_size(1024 * 1024 * 1024), "1.00 GB");
    assert_eq!(format_file_size(512), "512 B");
}

/// Helper function to format file sizes
fn format_file_size(bytes: u64) -> String {
    const UNITS: &[&str] = &["B", "KB", "MB", "GB", "TB"];
    let mut size = bytes as f64;
    let mut unit_index = 0;
    
    while size >= 1024.0 && unit_index < UNITS.len() - 1 {
        size /= 1024.0;
        unit_index += 1;
    }
    
    if unit_index == 0 {
        format!("{} {}", bytes, UNITS[unit_index])
    } else {
        format!("{:.2} {}", size, UNITS[unit_index])
    }
}

/// Test command line interface basics
#[test]
fn test_cli_basics() {
    // Test that basic CLI structures work
    let test_url = "https://github.com/user/repo/releases/download/v1.0.0/file.zip";
    
    // Test URL parsing
    assert!(url::Url::parse(test_url).is_ok());
    
    // Test filename extraction
    let path = std::path::Path::new(test_url);
    let filename = path.file_name().unwrap().to_str().unwrap();
    assert_eq!(filename, "file.zip");
}
